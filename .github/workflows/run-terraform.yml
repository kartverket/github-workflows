name: Run Terraform

on:
  workflow_call:
    inputs:
      workload_identity_provider:
        description: "The ID of the provider to use for authentication. It should be in the format of `projects/{{project}}/locations/global/workloadIdentityPools/{{workload_identity_pool_id}}/providers/{{workload_identity_pool_provider_id}}`"
        required: true
        type: string
      service_account:
        description: "The GCP service account connected to the identity pool that will be used by Terraform"
        required: true
        type: string
      runner:
        description: "The GitHub runner to use when running the deploy. This can for example be `atkv1-dev`"
        required: true
        type: string
      deploy_on:
        description: "Which branch will be the only branch allowed to deploy. This defaults to the main branch so that other branches only run check and plan. Defaults to `refs/heads/main`"
        required: false
        type: string
        default: "refs/heads/main"
      working_directory:
        description: "The directory in which to run terraform, i.e. where the Terraform files are placed. The path is relative to the root of the repository"
        required: false
        type: string
        default: "."
      project_id:
        description: 'The GCP Project ID to use as the "active project" when running Terraform. When deploying to Kubernetes, this must match the project in which the Kubernetes cluster is registered'
        required: false
        type: string
      environment:
        description: "The GitHub environment to use when deploying. See [using environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment) for more info on this"
        required: false
        type: string
      kubernetes_cluster:
        description: "An optional kubernetes cluster to authenticate to. Note that the project_id must match where the cluster is registered"
        required: false
        type: string
      terraform_workspace:
        description: "When provided will set a workspace as the active workspace when planning and deploying"
        required: false
        type: string
      terraform_options:
        description: "Any additional terraform options to be passed to plan and apply. For example `-var-file=dev.tfvars` and `-var=<variableName>=<variableValue>`"
        required: false
        type: string
      terraform_backend_config:
        description: "Any additional terraform backend-config to be passed to init. For example `-backend-config=dev.gcs.tfbackend`"
        required: false
        type: string
      vault_role:
        description: "Required when using vault in terraform. Enables fetching jwt and logging in to vault for the terraform provider to work"
        required: false
        type: string
      image_url:
        description: "Setting an image_url of the form registry/repository:tag or registry/repository@digest enables the binary attestation of that image."
        required: false
        type: string
        default: ""
      add_comment_on_pr:
        description: "Setting this to `false` disables the creation of comments with info of the Terraform run on Pull Requests. When `true` the `pull-request` permission is required to be set to `write`. Defaults to `true`"
        required: false
        type: boolean
        default: true
      destroy:
        description: "An optional boolean which runs terraform destroy when set to true. Defaluts to false"
        required: false
        type: boolean
        default: false

jobs:
  terraform_check:
    name: Terraform Validate
    runs-on: ubuntu-latest
    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}

    outputs:
      validate_outcome: ${{ steps.validate.outcome }}
      validate_stdout: ${{ steps.validate.outputs.stdout}}
      format_outcome: ${{ steps.format.outcome }}

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v3

      # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v0
        with:
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}
          project_id: ${{ inputs.project_id }}

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        run: terraform init -backend=false

      - name: Terraform Validate
        id: validate
        continue-on-error: true
        run: |
          echo 'Run validate' | tee $GITHUB_STEP_SUMMARY
          terraform validate -no-color | tee -a output.txt
          cat output.txt | sed '/^::/d' >> $GITHUB_STEP_SUMMARY

      # Checks that all Terraform configuration files adhere to a canonical format
      - name: Terraform Format
        id: format
        env:
          WORKING_DIRECTORY: ${{ inputs.working_directory }}
        run: |
          echo 'Run format check' | tee -a $GITHUB_STEP_SUMMARY
          terraform fmt -check -no-color || { echo '
          FAILURE! The above files are not properly formatted.
          Run `terraform fmt` in $WORKING_DIRECTORY, commit the changed files and push to fix the issue' | tee -a $GITHUB_STEP_SUMMARY ; exit 1; }

  terraform_plan:
    name: Terraform Plan
    runs-on: ${{ inputs.runner }}

    # Disallow parallel jobs for same env to allow aquiring state lock instead of crashing
    concurrency: ${{ inputs.environment }}

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}

    outputs:
      init_outcome: ${{ steps.init.outcome }}
      plan_exitcode: ${{ steps.plan.outputs.exitcode }}
      plan_outcome: ${{ steps.plan.outcome }}
      plan_stdout: ${{ steps.plan.outputs.stdout }}

    env:
      # makes some minor adjustments to Terraforms output to de-emphasize specific commands to run
      TF_IN_AUTOMATION: true
      WORKSPACE: ${{ inputs.terraform_workspace }}
      TF_BACKEND_CONFIG: ${{ inputs.terraform_backend_config }}
      TF_OPTIONS: ${{ inputs.terraform_options }}

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v3

      # Node is required for terraform_wrapper on-prem
      - uses: actions/setup-node@v3
        with:
          node-version: 16

      # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
      - name: Setup Terraform
        # Change to v2.1.0 when released. We require the below fix:
        # https://github.com/hashicorp/setup-terraform/pull/125
        uses: hashicorp/setup-terraform@78ea3ac2fbe8fe4dab277d1cbd1e6435a91a49cc

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v0
        with:
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}
          project_id: ${{ inputs.project_id }}

      - name: Authenticate with Kubernetes
        if: inputs.kubernetes_cluster != ''
        env:
          KUBERNETES_CLUSTER: ${{ inputs.kubernetes_cluster }}
        run: gcloud container hub memberships get-credentials $KUBERNETES_CLUSTER --verbosity debug

      - name: Authenticate with Vault
        if: inputs.vault_role != ''
        uses: kartverket/vault-jwt-auth-action@v2
        with:
          vaultaddr: "https://vault.${{ inputs.environment }}.skip.statkart.no"
          path: jwt-${{ inputs.environment }}
          role: ${{ inputs.vault_role }}
          certb64: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURoakNDQW02Z0F3SUJBZ0lRSHhRNCszNDQ1TFJDazN6ZlVUUENPekFOQmdrcWhraUc5dzBCQVFzRkFEQkwKTVJJd0VBWUtDWkltaVpQeUxHUUJHUllDYm04eEdEQVdCZ29Ka2lhSmsvSXNaQUVaRmdoemRHRjBhMkZ5ZERFYgpNQmtHQTFVRUF4TVNTMkZ5ZEhabGNtdGxkQ0JTYjI5MElFTkJNQjRYRFRFMk1ETXlNakUwTURJek0xb1hEVFEyCk1ETXlNakUwTVRJek0xb3dTekVTTUJBR0NnbVNKb21UOGl4a0FSa1dBbTV2TVJnd0ZnWUtDWkltaVpQeUxHUUIKR1JZSWMzUmhkR3RoY25ReEd6QVpCZ05WQkFNVEVrdGhjblIyWlhKclpYUWdVbTl2ZENCRFFUQ0NBU0l3RFFZSgpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKSjBaMWExNEpYblkxSUptaDgweGgwSFhKZmZZZ2lXCjVFRGtxOUVFUXRPYk1SUlVDbm16aUlDQ3lPM3hLQUdqWEJ1aFowL21vVUJnUXFwbWtDSlIvQ1pubnNJMVZ6QVkKMHNPbWlRaFVNSVdCUzhDRkltVWNoTmJOREM1SzZYVStwNGZodWxFN0lPL3FTZDd3V2dNSFZLdUE5eVBvVFJsMwowaVpZdG5IcUlCb3dZS3dJVHBBSmpwME5hTmNIalY2TWVOdlBrR1RURk45S1MxcG53QjhZVnFVYUZXdDJGVDh1CjBSTE9kUUgyeFFva1l4YW1RRWNqaEFBSnlzVDdkK25YemRzYUEwYXQrYlNwUExxTURVOW5JZFpuRGc1TlgyY0oKcnNlRm5tWTJ3Q2NLL2tMUUpVSWxSQVQ0UHI5Y08rZDRvSytRTFFOaGZpVmxUa0RaZU1ISHhia0NBd0VBQWFObQpNR1F3RXdZSkt3WUJCQUdDTnhRQ0JBWWVCQUJEQUVFd0N3WURWUjBQQkFRREFnR0dNQThHQTFVZEV3RUIvd1FGCk1BTUJBZjh3SFFZRFZSME9CQllFRk5xNUhyME9mV3kzbWMvckxXUEZrMHpmSWhlck1CQUdDU3NHQVFRQmdqY1YKQVFRREFnRUFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUJkdHFVbDdvWFFTYWxIWjh6Y2dRZllvZWVxTGNwRQp5RjhFUngwdnFQc0hmY2VnL0ZXZEhFUVh4TWtPN1JER1Fzb2NmTVZvR0FBT1R3VlFPTHZCNmg4MnhCRVozSjBqCjBGMWkvcSs0WEd2NjdvOW43Z2NLNUFGOVNhcy9MVFB4N3dqQjV2dS85TkxyRkE1eXgyUG1iRnpNNFZRcXkwZnQKd2loaTdxMlhoQlVYUGo0SEdhTVE2aE1CYkRhSVl0Z0ovWWlkTFpSeGZWQVpGVEN4UDlPcDZVR3d0Zi9DeHdPSQo5ZkxtaWIwUDZCWG9sR3h1eU5XdHU2K0Vxc1JtMGtvcE5jcDkyZWpiOGsyb3R4VWdRcGNoVzRwd2RLMWZ3azhECndVblY5emhTc2k5eVZGMVVRUDZRcEJCeFNDZE5PT3JSSEg0N1djZmF0VUg0SWhuQW9PS0VyUVpBCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      #
      #    echo "${options[@]}"
      - name: Terraform Pre-Init
        if: inputs.terraform_workspace != ''
        run: |
          IFS='|' read -r -a options <<< "$TF_BACKEND_CONFIG"
          echo "${options[@]}"
          terraform init "${options[@]}"

      - name: Select/Create Terraform Workspace
        if: inputs.terraform_workspace != ''
        run: |
          echo "TF_WORKSPACE=$WORKSPACE" >> $GITHUB_ENV
          terraform workspace select $WORKSPACE || terraform workspace new $WORKSPACE

      # Initialize again in case a new workspace was selected
      - name: Terraform Init
        id: init
        run: terraform init "${options[@]}"

      - name: Terraform Plan
        id: plan
        env:
          ENV: ${{ inputs.environment }}
        run: |
          # 1. Run and send stdout to build log as usual
          terraform plan $TF_OPTIONS -input=false -no-color -detailed-exitcode -out=plan-$ENV.tfplan | tee output.txt

          # 2. Remove some github commands and fluff
          STDOUT="$(sed '/^::/d' output.txt | grep -v 'Refreshing state...')"

          # 3. Write to step summary
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          \`\`\`
          ${STDOUT}
          \`\`\`
          EOF

          # 4. Serialize into single-line string for transfer using outputs that only support single line
          STDOUT="${STDOUT//'%'/'%25'}"
          STDOUT="${STDOUT//$'\n'/'%0A'}"
          STDOUT="${STDOUT//$'\r'/'%0D'}"

          # 5. Write output 
          echo "stdout=$STDOUT" >> $GITHUB_OUTPUT

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v3
        with:
          name: plan-${{ inputs.environment }}.tfplan
          path: ${{ inputs.working_directory }}/plan-${{ inputs.environment }}.tfplan
          retention-days: 5

  update_github:
    if: ${{ always() && inputs.add_comment_on_pr == true && github.event_name == 'pull_request' }}
    needs: [terraform_check, terraform_plan]
    name: Update GitHub
    runs-on: ubuntu-latest

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Update Pull Request
        uses: actions/github-script@v6
        env:
          # Passing via env vars to sanitize untrusted inputs
          ENV: ${{ inputs.environment }}
          PLAN_EXITCODE: ${{ needs.terraform_plan.outputs.plan_exitcode }}
          DEPLOY_ON: ${{ inputs.deploy_on }}
          VALIDATE_OUTPUT: ${{ needs.terraform_check.outputs.validate_stdout }}
          PLAN_OUTPUT: ${{ needs.terraform_plan.outputs.plan_stdout }}
          FORMAT_OUTCOME: ${{ needs.terraform_check.outputs.format_outcome }}
          INIT_OUTCOME: ${{ needs.terraform_plan.outputs.init_outcome }}
          VALIDATE_OUTCOME: ${{ needs.terraform_check.outputs.validate_outcome }}
          PLAN_OUTCOME: ${{ needs.terraform_plan.outputs.plan_outcome }}
          WORKING_DIRECTORY: ${{ inputs.working_directory }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            const {
              ENV,
              PLAN_EXITCODE,
              DEPLOY_ON,
              VALIDATE_OUTPUT,
              PLAN_OUTPUT,
              FORMAT_OUTCOME,
              INIT_OUTCOME,
              VALIDATE_OUTCOME,
              PLAN_OUTCOME,
              WORKING_DIRECTORY,
            } = process.env;

            /* Body is in the format of
            * <!-- @run-terraform -->
            * <!-- @run-terraform:start:jobid -->
            * Output of job with id jobid
            * <!-- @run-terraform:end:jobid -->
            */
            const bodyStartMarker = '<!-- @run-terraform -->';
            const comment = comments.find(({ body }) => body.startsWith(bodyStartMarker));
            const id = comment?.id;
            let commentBody = comment?.body ?? bodyStartMarker;
            const bodyHasJobInfo = commentBody.includes(`<!-- @run-terraform:start:${ENV} -->`);

            const exitcode = PLAN_EXITCODE;
            const action = {
              0: 'No changes detected. Will not run Terraform apply job',
              1: 'An error occured! Will not run Terraform apply job',
              2: `Changes detected. Will run Terraform apply job on merge to ${DEPLOY_ON}`
            }[exitcode] ?? 'Terraform gave an unknown exit code, I don\'t know what happens next!';

            const jobBody = `<!-- @run-terraform:start:${ENV} -->
            ## Results for ${ENV} ${exitcode === '2' ? '‚Äì ‚ùó `CHANGED` ‚ùó' : ''}
            #### Terraform Format and Style üñå \`${FORMAT_OUTCOME}\`
            #### Terraform Initialization ‚öôÔ∏è \`${INIT_OUTCOME}\`
            #### Terraform Validation ü§ñ \`${VALIDATE_OUTCOME}\`
            <details><summary>Validation Output</summary>

            \`\`\`\n
            ${VALIDATE_OUTPUT}
            \`\`\`

            </details>

            #### Terraform Plan üìñ \`${PLAN_OUTCOME}\`

            <details><summary>Show Plan</summary>

            \`\`\`\n
            ${PLAN_OUTPUT}
            \`\`\`

            </details>

            #### Next action üöÄ
            ${action}

            *Pusher: @${{ github.actor }}, Working Directory: \`${WORKING_DIRECTORY}\`, Commit: ${{ github.sha }}, Generated at: \`${new Date().toLocaleString('nb')}\`*
            <!-- @run-terraform:end:${ENV} -->`;

            if (bodyHasJobInfo) {
              commentBody = commentBody.replace(
                new RegExp(`<!-- @run-terraform:start:${ENV} -->.*<!-- @run-terraform:end:${ENV} -->`, 's'),
                jobBody,
              );
            } else {
              commentBody += '\n' + jobBody;
            }

            commentBody = commentBody
              .replaceAll("%0A", "\n")
              .replaceAll("%0D", "\n");

            if (id) {
              github.rest.issues.updateComment({
                comment_id: id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              })
            } else {
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: commentBody
              })
            }

  run_terraform:
    # TODO We need to verify that inputs.deploy_on actually works. Seems to only work on main atm
    needs: [terraform_check, terraform_plan]
    if: github.ref == inputs.deploy_on && github.event_name == 'push' && (needs.terraform_plan.outputs.plan_exitcode == '2' || inputs.destroy == true)
    name: Terraform Apply or Destroy
    runs-on: ${{ inputs.runner }}
    environment: ${{ inputs.environment }}

    # Disallow parallel jobs for same env to allow aquiring state lock instead of crashing
    concurrency: ${{ inputs.environment }}

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}

    env:
      # makes some minor adjustments to Terraforms output to de-emphasize specific commands to run
      TF_IN_AUTOMATION: true
      TF_WORKSPACE: ${{ inputs.terraform_workspace }}

    steps:
      # Checkout the repository to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v3

      # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v0
        with:
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}
          project_id: ${{ inputs.project_id }}

      - name: Authenticate with Kubernetes
        if: inputs.kubernetes_cluster != ''
        env:
          KUBERNETES_CLUSTER: ${{ inputs.kubernetes_cluster }}
        run: gcloud container hub memberships get-credentials $KUBERNETES_CLUSTER --verbosity debug

      - name: Authenticate with Vault
        if: inputs.vault_role != ''
        uses: kartverket/vault-jwt-auth-action@v2
        with:
          vaultaddr: "https://vault.${{ inputs.environment }}.skip.statkart.no"
          path: jwt-${{ inputs.environment }}
          role: ${{ inputs.vault_role }}
          certb64: "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURoakNDQW02Z0F3SUJBZ0lRSHhRNCszNDQ1TFJDazN6ZlVUUENPekFOQmdrcWhraUc5dzBCQVFzRkFEQkwKTVJJd0VBWUtDWkltaVpQeUxHUUJHUllDYm04eEdEQVdCZ29Ka2lhSmsvSXNaQUVaRmdoemRHRjBhMkZ5ZERFYgpNQmtHQTFVRUF4TVNTMkZ5ZEhabGNtdGxkQ0JTYjI5MElFTkJNQjRYRFRFMk1ETXlNakUwTURJek0xb1hEVFEyCk1ETXlNakUwTVRJek0xb3dTekVTTUJBR0NnbVNKb21UOGl4a0FSa1dBbTV2TVJnd0ZnWUtDWkltaVpQeUxHUUIKR1JZSWMzUmhkR3RoY25ReEd6QVpCZ05WQkFNVEVrdGhjblIyWlhKclpYUWdVbTl2ZENCRFFUQ0NBU0l3RFFZSgpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKSjBaMWExNEpYblkxSUptaDgweGgwSFhKZmZZZ2lXCjVFRGtxOUVFUXRPYk1SUlVDbm16aUlDQ3lPM3hLQUdqWEJ1aFowL21vVUJnUXFwbWtDSlIvQ1pubnNJMVZ6QVkKMHNPbWlRaFVNSVdCUzhDRkltVWNoTmJOREM1SzZYVStwNGZodWxFN0lPL3FTZDd3V2dNSFZLdUE5eVBvVFJsMwowaVpZdG5IcUlCb3dZS3dJVHBBSmpwME5hTmNIalY2TWVOdlBrR1RURk45S1MxcG53QjhZVnFVYUZXdDJGVDh1CjBSTE9kUUgyeFFva1l4YW1RRWNqaEFBSnlzVDdkK25YemRzYUEwYXQrYlNwUExxTURVOW5JZFpuRGc1TlgyY0oKcnNlRm5tWTJ3Q2NLL2tMUUpVSWxSQVQ0UHI5Y08rZDRvSytRTFFOaGZpVmxUa0RaZU1ISHhia0NBd0VBQWFObQpNR1F3RXdZSkt3WUJCQUdDTnhRQ0JBWWVCQUJEQUVFd0N3WURWUjBQQkFRREFnR0dNQThHQTFVZEV3RUIvd1FGCk1BTUJBZjh3SFFZRFZSME9CQllFRk5xNUhyME9mV3kzbWMvckxXUEZrMHpmSWhlck1CQUdDU3NHQVFRQmdqY1YKQVFRREFnRUFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUJkdHFVbDdvWFFTYWxIWjh6Y2dRZllvZWVxTGNwRQp5RjhFUngwdnFQc0hmY2VnL0ZXZEhFUVh4TWtPN1JER1Fzb2NmTVZvR0FBT1R3VlFPTHZCNmg4MnhCRVozSjBqCjBGMWkvcSs0WEd2NjdvOW43Z2NLNUFGOVNhcy9MVFB4N3dqQjV2dS85TkxyRkE1eXgyUG1iRnpNNFZRcXkwZnQKd2loaTdxMlhoQlVYUGo0SEdhTVE2aE1CYkRhSVl0Z0ovWWlkTFpSeGZWQVpGVEN4UDlPcDZVR3d0Zi9DeHdPSQo5ZkxtaWIwUDZCWG9sR3h1eU5XdHU2K0Vxc1JtMGtvcE5jcDkyZWpiOGsyb3R4VWdRcGNoVzRwd2RLMWZ3azhECndVblY5emhTc2k5eVZGMVVRUDZRcEJCeFNDZE5PT3JSSEg0N1djZmF0VUg0SWhuQW9PS0VyUVpBCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K"

      - name: Download Plan Artifact
        uses: actions/download-artifact@v3
        with:
          name: plan-${{ inputs.environment }}.tfplan
          path: ${{ inputs.working_directory }}

      # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
      - name: Terraform Init
        run: terraform init ${{ inputs.terraform_backend_config }}

      # Run terraform destroy on push to main if 'destroy' is set to true
      - name: Terraform Destroy
        if: inputs.destroy == true
        id: destroy
        run: terraform destroy ${{ inputs.terraform_options }} -auto-approve

      - name: Run Terraform
        if: inputs.destroy == false
        env:
          ENV: ${{ inputs.environment }}
        run: |
          terraform apply -input=false plan-$ENV.tfplan

  attest-deploy:
    if: inputs.image_url != '' && (inputs.environment == 'dev' || inputs.environment == 'test')
    name: Attest deploy to environment
    needs: run_terraform
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v0
        with:
          workload_identity_provider: ${{ inputs.workload_identity_provider }}
          service_account: ${{ inputs.service_account }}

      - name: Get Image Digest URL from Image Tag URL
        id: image-digest-url
        env:
          IMAGE_URL: ${{ inputs.image_url }}
        run: |
          # If image_url = registry/repository@digest
          if [[ "$IMAGE_URL" == *"@"* ]] 
          then
            image_digest_url="$IMAGE_URL"
          else
            # Convert registry/repository:tag to registry/repository@digest
            image_tag_url=$IMAGE_URL
            digest=$(docker manifest inspect $image_tag_url -v | jq -r .Descriptor.digest)
            base_image_url=${image_tag_url%:*}
            image_digest_url="${base_image_url}@${digest}"
          fi
          echo "image_url=$image_digest_url" >> $GITHUB_OUTPUT

      - name: Check if already attested
        id: get-attestation
        env:
          ENV: ${{ inputs.env }}
          PROJECT_ID: ${{ inputs.project_id }}
        run: |
          attestation=$(gcloud container binauthz attestations list --project="$PROJECT_ID" --attestor="projects/$PROJECT_ID/attestors/Deploy-$ENV" --artifact-url="${{ steps.image-digest-url.outputs.image_url }}")
          attestationoutput=$(printf '%s' $attestation | jq --raw-input --slurp '.' --join-output)
          echo "attestation=$attestationoutput" >> $GITHUB_OUTPUT

      # Attestor name: Deploy-Dev
      - name: Perform attestation of deploy to ${{inputs.environment}}
        id: attest-deploy
        # Note: msg is an empty string when no attestation is done
        if: steps.get-attestation.outputs.attestation == ''
        env:
          ENV: ${{ inputs.env }}
          PROJECT_ID: ${{ inputs.project_id }}
          IMAGE_URL: ${{ steps.image-digest-url.outputs.image_url }}
        run: |
          gcloud beta container binauthz attestations sign-and-create \
            --project="$PROJECT_ID" \
            --artifact-url="$IMAGE_URL" \
            --attestor="Deploy-$ENV" \
            --attestor-project="$PROJECT_ID" \
            --keyversion-project="$PROJECT_ID" \
            --keyversion-location="europe-north1" \
            --keyversion-keyring="Attestor-Keyring" \
            --keyversion-key="Deploy-$ENV-Key" \
            --keyversion="1"
          echo Attestation succeded
