name: Run Terraform

on:
  workflow_call:
    inputs:
      workload_identity_provider:
        description: ""
        required: true
        type: string
      service_account:
        description: ""
        required: true
        type: string
      runner:
        description: ""
        required: true
        type: string
      deploy_on:
        description: ""
        required: false
        type: string
        default: 'refs/heads/main'
      working_directory:
        description: ""
        required: false
        type: string
      project_id:
        description: ""
        required: false
        type: string
      environment:
        description: ""
        required: false
        type: string
      kubernetes_cluster:
        description: ""
        required: false
        type: string
      terraform_workspace:
        description: ""
        required: false
        type: string
      terraform_options:
        description: ""
        required: false
        type: string
      vault_role:
        description: ""
        required: false
        type: string
      add_comment_on_pr:
        description: ""
        required: false
        type: boolean
        default: true

jobs:
  terraform_check:
    name: Terraform Validate
    runs-on: ubuntu-latest

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}

    outputs:
      validate_outcome: ${{ steps.validate.outcome }}
      validate_stdout: ${{ steps.validate.outputs.stdout}}
      format_outcome: ${{ steps.format.outcome }}

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init -backend=false

    - name: Terraform Validate
      id: validate
      continue-on-error: true
      run: |
        echo 'Run validate' | tee $GITHUB_STEP_SUMMARY
        terraform validate -no-color | tee -a $GITHUB_STEP_SUMMARY

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      id: format
      run: |
        echo 'Run format check' | tee -a $GITHUB_STEP_SUMMARY
        terraform fmt -check -no-color || { echo '
        FAILURE! The above files are not properly formatted.
        Run `terraform fmt` in ${{inputs.working_directory}}, commit the changed files and push to fix the issue' | tee -a $GITHUB_STEP_SUMMARY ; exit 1; }

  terraform_plan:
    name: Terraform Plan
    runs-on: ${{ inputs.runner }}

    # Disallow parallel jobs for same env to allow aquiring state lock instead of crashing
    concurrency: ${{ inputs.environment }}

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}

    outputs:
      init_outcome: ${{ steps.init.outcome }}
      plan_exitcode: ${{ steps.plan.outputs.exitcode }}
      plan_outcome: ${{ steps.plan.outcome }}
      plan_stdout: ${{ steps.plan.outputs.stdout }}
    
    env:
      # makes some minor adjustments to Terraforms output to de-emphasize specific commands to run
      TF_IN_AUTOMATION: true
      TF_WORKSPACE: ${{ inputs.terraform_workspace }}

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    # Node is required for terraform_wrapper on-prem
    - uses: actions/setup-node@v3
      with:
        node-version: 16

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      # Change to v2.1.0 when released. We require the below fix:
      # https://github.com/hashicorp/setup-terraform/pull/125
      uses: hashicorp/setup-terraform@78ea3ac2fbe8fe4dab277d1cbd1e6435a91a49cc

    - name: Authenticate with Google Cloud
      uses: google-github-actions/auth@v0
      with:
        workload_identity_provider: ${{ inputs.workload_identity_provider }}
        service_account: ${{ inputs.service_account }}
        project_id: ${{ inputs.project_id }}

    - name: Authenticate with Kubernetes
      if: inputs.kubernetes_cluster != ''
      run: gcloud container hub memberships get-credentials ${{ inputs.kubernetes_cluster }} --verbosity debug

    - name: Authenticate with Vault
      if: inputs.vault_role != ''
      uses: kartverket/vault-jwt-auth-action@v2
      with:
        vaultaddr: 'https://vault.${{inputs.environment}}.skip.statkart.no'
        path: jwt-${{inputs.environment}}
        role: ${{inputs.vault_role}}
        certb64: 'LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURoakNDQW02Z0F3SUJBZ0lRSHhRNCszNDQ1TFJDazN6ZlVUUENPekFOQmdrcWhraUc5dzBCQVFzRkFEQkwKTVJJd0VBWUtDWkltaVpQeUxHUUJHUllDYm04eEdEQVdCZ29Ka2lhSmsvSXNaQUVaRmdoemRHRjBhMkZ5ZERFYgpNQmtHQTFVRUF4TVNTMkZ5ZEhabGNtdGxkQ0JTYjI5MElFTkJNQjRYRFRFMk1ETXlNakUwTURJek0xb1hEVFEyCk1ETXlNakUwTVRJek0xb3dTekVTTUJBR0NnbVNKb21UOGl4a0FSa1dBbTV2TVJnd0ZnWUtDWkltaVpQeUxHUUIKR1JZSWMzUmhkR3RoY25ReEd6QVpCZ05WQkFNVEVrdGhjblIyWlhKclpYUWdVbTl2ZENCRFFUQ0NBU0l3RFFZSgpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKSjBaMWExNEpYblkxSUptaDgweGgwSFhKZmZZZ2lXCjVFRGtxOUVFUXRPYk1SUlVDbm16aUlDQ3lPM3hLQUdqWEJ1aFowL21vVUJnUXFwbWtDSlIvQ1pubnNJMVZ6QVkKMHNPbWlRaFVNSVdCUzhDRkltVWNoTmJOREM1SzZYVStwNGZodWxFN0lPL3FTZDd3V2dNSFZLdUE5eVBvVFJsMwowaVpZdG5IcUlCb3dZS3dJVHBBSmpwME5hTmNIalY2TWVOdlBrR1RURk45S1MxcG53QjhZVnFVYUZXdDJGVDh1CjBSTE9kUUgyeFFva1l4YW1RRWNqaEFBSnlzVDdkK25YemRzYUEwYXQrYlNwUExxTURVOW5JZFpuRGc1TlgyY0oKcnNlRm5tWTJ3Q2NLL2tMUUpVSWxSQVQ0UHI5Y08rZDRvSytRTFFOaGZpVmxUa0RaZU1ISHhia0NBd0VBQWFObQpNR1F3RXdZSkt3WUJCQUdDTnhRQ0JBWWVCQUJEQUVFd0N3WURWUjBQQkFRREFnR0dNQThHQTFVZEV3RUIvd1FGCk1BTUJBZjh3SFFZRFZSME9CQllFRk5xNUhyME9mV3kzbWMvckxXUEZrMHpmSWhlck1CQUdDU3NHQVFRQmdqY1YKQVFRREFnRUFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUJkdHFVbDdvWFFTYWxIWjh6Y2dRZllvZWVxTGNwRQp5RjhFUngwdnFQc0hmY2VnL0ZXZEhFUVh4TWtPN1JER1Fzb2NmTVZvR0FBT1R3VlFPTHZCNmg4MnhCRVozSjBqCjBGMWkvcSs0WEd2NjdvOW43Z2NLNUFGOVNhcy9MVFB4N3dqQjV2dS85TkxyRkE1eXgyUG1iRnpNNFZRcXkwZnQKd2loaTdxMlhoQlVYUGo0SEdhTVE2aE1CYkRhSVl0Z0ovWWlkTFpSeGZWQVpGVEN4UDlPcDZVR3d0Zi9DeHdPSQo5ZkxtaWIwUDZCWG9sR3h1eU5XdHU2K0Vxc1JtMGtvcE5jcDkyZWpiOGsyb3R4VWdRcGNoVzRwd2RLMWZ3azhECndVblY5emhTc2k5eVZGMVVRUDZRcEJCeFNDZE5PT3JSSEg0N1djZmF0VUg0SWhuQW9PS0VyUVpBCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K'

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      id: init
      run: terraform init

    - name: Terraform Plan
      id: plan
      run: |
        # 1. Run and send stdout to build log as usual
        STDOUT=$(terraform plan ${{inputs.terraform_options}} -input=false -no-color -detailed-exitcode -out=plan-${{ inputs.environment }}.tfplan)
        echo $STDOUT

        # 2. Remove some github commands and fluff
        STDOUT="$(echo $STDOUT | sed '/^::/d' | grep -v 'Refreshing state...')"

        # 3. Serialize into single-line string for transfer using outputs that only support single line
        STDOUT="${STDOUT//'%'/'%25'}"
        STDOUT="${STDOUT//$'\n'/'%0A'}"
        STDOUT="${STDOUT//$'\r'/'%0D'}"

        # 4. Write output and step summary
        echo "::set-output name=stdout::$STDOUT"
        cat <<EOF
        ```
        ${STDOUT}
        ```
        EOF >> $GITHUB_STEP_SUMMARY

    - name: Upload Plan Artifact
      uses: actions/upload-artifact@v3
      with:
        name: plan-${{ inputs.environment }}.tfplan
        path: ${{ inputs.working_directory }}/plan-${{ inputs.environment }}.tfplan
        retention-days: 5

  update_github:
    if: ${{ always() && inputs.add_comment_on_pr == true && github.event_name == 'pull_request' }}
    needs: [terraform_check, terraform_plan]
    name: Update GitHub
    runs-on: ubuntu-latest

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    steps:
    - name: Update Pull Request
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { data: comments } = await github.rest.issues.listComments({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo
          });

          /* Body is in the format of
          * <!-- @run-terraform -->
          * <!-- @run-terraform:start:jobid -->
          * Output of job with id jobid
          * <!-- @run-terraform:end:jobid -->
          */
          const bodyStartMarker = '<!-- @run-terraform -->';
          const comment = comments.find(({ body }) => body.startsWith(bodyStartMarker));
          const id = comment?.id;
          let commentBody = comment?.body ?? bodyStartMarker;
          const bodyHasJobInfo = commentBody.includes('<!-- @run-terraform:start:${{ inputs.environment }} -->');

          const exitcode = ${{ needs.terraform_plan.outputs.plan_exitcode }};
          const action = {
            0: 'No changes, skipping Terraform apply job',
            1: 'Error occured! Aborting',
            2: 'Changes detected, running Terraform apply job'
          }[exitcode] ?? 'Terraform gave an unknown exit code, I don\'t know what happens next!';
          
          const jobBody = `<!-- @run-terraform:start:${{ inputs.environment }} -->
          ## Results for ${{ inputs.environment }} ${exitcode === 2 ? '‚Äì `CHANGED`' : ''}
          #### Terraform Format and Style üñå \`${{ needs.terraform_check.outputs.format_outcome }}\`
          #### Terraform Initialization ‚öôÔ∏è \`${{ needs.terraform_plan.outputs.init_outcome }}\`
          #### Terraform Validation ü§ñ \`${{ needs.terraform_check.outputs.validate_outcome }}\`
          <details><summary>Validation Output</summary>

          \`\`\`\n
          ${{ needs.terraform_check.outputs.validate_stdout }}
          \`\`\`

          </details>

          #### Terraform Plan üìñ \`${{ needs.terraform_plan.outputs.plan_outcome }}\`
          
          <details><summary>Show Plan</summary>
          
          \`\`\`\n
          ${{ needs.terraform_plan.outputs.plan_stdout }}
          \`\`\`
          
          </details>

          #### Next action üöÄ
          ${action}
          
          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Working Directory: \`${{ inputs.working_directory }}\`, Workflow: \`${{ github.workflow }}\`*
          <!-- @run-terraform:end:${{ inputs.environment }} -->`;

          if (bodyHasJobInfo) {
            commentBody = commentBody.replace(
              /<!-- @run-terraform:start:${{ inputs.environment }} -->.*<!-- @run-terraform:end:${{ inputs.environment }} -->/s,
              jobBody,
            );
          } else {
            commentBody += '\n' + jobBody;
          }

          if (id) {
            github.rest.issues.updateComment({
              comment_id: id,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            })
          } else {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            })
          }

  run_terraform:
    # TODO We need to verify that inputs.deploy_on actually works. Seems to only work on main atm
    if: github.ref == inputs.deploy_on && needs.terraform_plan.outputs.plan_exitcode == '2' && github.event_name == 'push'
    needs: [terraform_check, terraform_plan]
    name: Terraform Apply
    runs-on: ${{ inputs.runner }}
    environment: ${{ inputs.environment }}

    # Disallow parallel jobs for same env to allow aquiring state lock instead of crashing
    concurrency: ${{ inputs.environment }}

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ inputs.working_directory }}

    env:
      # makes some minor adjustments to Terraforms output to de-emphasize specific commands to run
      TF_IN_AUTOMATION: true
      TF_WORKSPACE: ${{ inputs.terraform_workspace }}

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3

    # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_wrapper: false

    - name: Authenticate with Google Cloud
      uses: google-github-actions/auth@v0
      with:
        workload_identity_provider: ${{ inputs.workload_identity_provider }}
        service_account: ${{ inputs.service_account }}
        project_id: ${{ inputs.project_id }}

    - name: Authenticate with Kubernetes
      if: inputs.kubernetes_cluster != ''
      run: gcloud container hub memberships get-credentials ${{ inputs.kubernetes_cluster }} --verbosity debug

    - name: Authenticate with Vault
      if: inputs.vault_role != ''
      uses: kartverket/vault-jwt-auth-action@v2
      with:
        vaultaddr: 'https://vault.${{inputs.environment}}.skip.statkart.no'
        path: jwt-${{inputs.environment}}
        role: ${{inputs.vault_role}}
        certb64: 'LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURoakNDQW02Z0F3SUJBZ0lRSHhRNCszNDQ1TFJDazN6ZlVUUENPekFOQmdrcWhraUc5dzBCQVFzRkFEQkwKTVJJd0VBWUtDWkltaVpQeUxHUUJHUllDYm04eEdEQVdCZ29Ka2lhSmsvSXNaQUVaRmdoemRHRjBhMkZ5ZERFYgpNQmtHQTFVRUF4TVNTMkZ5ZEhabGNtdGxkQ0JTYjI5MElFTkJNQjRYRFRFMk1ETXlNakUwTURJek0xb1hEVFEyCk1ETXlNakUwTVRJek0xb3dTekVTTUJBR0NnbVNKb21UOGl4a0FSa1dBbTV2TVJnd0ZnWUtDWkltaVpQeUxHUUIKR1JZSWMzUmhkR3RoY25ReEd6QVpCZ05WQkFNVEVrdGhjblIyWlhKclpYUWdVbTl2ZENCRFFUQ0NBU0l3RFFZSgpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFKSjBaMWExNEpYblkxSUptaDgweGgwSFhKZmZZZ2lXCjVFRGtxOUVFUXRPYk1SUlVDbm16aUlDQ3lPM3hLQUdqWEJ1aFowL21vVUJnUXFwbWtDSlIvQ1pubnNJMVZ6QVkKMHNPbWlRaFVNSVdCUzhDRkltVWNoTmJOREM1SzZYVStwNGZodWxFN0lPL3FTZDd3V2dNSFZLdUE5eVBvVFJsMwowaVpZdG5IcUlCb3dZS3dJVHBBSmpwME5hTmNIalY2TWVOdlBrR1RURk45S1MxcG53QjhZVnFVYUZXdDJGVDh1CjBSTE9kUUgyeFFva1l4YW1RRWNqaEFBSnlzVDdkK25YemRzYUEwYXQrYlNwUExxTURVOW5JZFpuRGc1TlgyY0oKcnNlRm5tWTJ3Q2NLL2tMUUpVSWxSQVQ0UHI5Y08rZDRvSytRTFFOaGZpVmxUa0RaZU1ISHhia0NBd0VBQWFObQpNR1F3RXdZSkt3WUJCQUdDTnhRQ0JBWWVCQUJEQUVFd0N3WURWUjBQQkFRREFnR0dNQThHQTFVZEV3RUIvd1FGCk1BTUJBZjh3SFFZRFZSME9CQllFRk5xNUhyME9mV3kzbWMvckxXUEZrMHpmSWhlck1CQUdDU3NHQVFRQmdqY1YKQVFRREFnRUFNQTBHQ1NxR1NJYjNEUUVCQ3dVQUE0SUJBUUJkdHFVbDdvWFFTYWxIWjh6Y2dRZllvZWVxTGNwRQp5RjhFUngwdnFQc0hmY2VnL0ZXZEhFUVh4TWtPN1JER1Fzb2NmTVZvR0FBT1R3VlFPTHZCNmg4MnhCRVozSjBqCjBGMWkvcSs0WEd2NjdvOW43Z2NLNUFGOVNhcy9MVFB4N3dqQjV2dS85TkxyRkE1eXgyUG1iRnpNNFZRcXkwZnQKd2loaTdxMlhoQlVYUGo0SEdhTVE2aE1CYkRhSVl0Z0ovWWlkTFpSeGZWQVpGVEN4UDlPcDZVR3d0Zi9DeHdPSQo5ZkxtaWIwUDZCWG9sR3h1eU5XdHU2K0Vxc1JtMGtvcE5jcDkyZWpiOGsyb3R4VWdRcGNoVzRwd2RLMWZ3azhECndVblY5emhTc2k5eVZGMVVRUDZRcEJCeFNDZE5PT3JSSEg0N1djZmF0VUg0SWhuQW9PS0VyUVpBCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K'

    - name: Download Plan Artifact
      uses: actions/download-artifact@v3
      with:
        name: plan-${{ inputs.environment }}.tfplan
        path: ${{ inputs.working_directory }}

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    - name: Run Terraform
      run: |
        terraform apply -input=false plan-${{ inputs.environment }}.tfplan
